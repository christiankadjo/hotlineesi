<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <title>Hotline ESI</title>
    <script src="/socket.io/socket.io.js"></script>
    <script src="dist/phaser.js"></script>
    <style type="text/css">
    body{
        margin:0;
    }
    </style>
</head>
<body>
    <script>
        const PLAYER_SPEED = 320;
        const PROJECTILE_SPEED = 600;
        const FIRERATE = 100;

        const LEFT="left";
        const RIGHT="right";
        const UP="up";
        const DOWN="down";
        const STOPX="stopx";
        const STOPY="stopy";

        var config = {
            type: Phaser.Auto,
            width:800,
            height:600,
            physics:{
                default:'arcade',
                arcade: {

                }
            },
            scene:{
                preload:preload,
                create: create,
                update: update
            }
        };
        var game = new Phaser.Game(config);
        var players = {};
        var cube;
        var bullets;
        var client = {};
        var nextFire = 0;

        var textDebug;
        var cursors;
        function preload()
        {
            this.load.image('floor', 'assets/floor.png');
            this.load.spritesheet('cube', 'assets/cube.png', {frameWidth:40, frameHeight:40});
            this.load.image('bullet', 'assets/bullet.png');
        }

        function create()
        {
            this.add.image(400,300,'floor');
            // cube = this.physics.add.sprite(400,300,'cube');
            // cube.setCollideWorldBounds(true);
            // cube.body.allowRotation = false;

            // bullets = new BulletGroup(this);
            this.input.setDefaultCursor('url(assets/crosshair.png), pointer');

            text = this.add.text(10, 10, 'Debug', { font: '16px Courier', fill: '#00ff00' });

            client.socket = io.connect();
            askNewPlayer();

            client.socket.on('newplayer', data =>{
                console.log("player");
                
                addNewPlayer(data.id,data.x,data.y, data.color, this)
            });

            client.socket.on('allplayers', data =>{
                console.log("allplayers", data);
                for(var i = 0; i < data.length; i++)
                {
                    addNewPlayer(data[i].id,data[i].x,data[i].y, data[i].color, this)
                }
                
            });

            client.socket.on('remove', id=>{
                players[id].destroy();
                delete players[id];
            });

            cursors = this.input.keyboard.createCursorKeys();
            

            client.socket.on('playerIsMoving', data=>{

                players[data.id].x = data.x;
                players[data.id].y = data.y;
            });

            client.socket.on('playerStop', data=>{

                players[data.id].x = data.x;
                players[data.id].y = data.y;
            });
            
        }

        function update()
        {

            playerMovementListener(cursors);
            // var angle =0;
            

            //playerMovement(cursors);

            // this.input.on('pointermove',function(pointer){
            //     angle = Phaser.Math.RAD_TO_DEG * Phaser.Math.Angle.BetweenPoints(cube, pointer);
            //     cube.setAngle(angle);
            // }, this);


            // this.input.on('pointerdown', pointer => {
            //     if(game.getTime()> nextFire)
            //     {
            //         nextFire = game.getTime() + FIRERATE;
            //         var bullet = bullets.getFirstDead(false); //getFirstDead will get the first child of the group that is considered dead... ie: The .alive property is false...
            //         if(bullet){
            //             bullet.shoot(cube.x,cube.y);
            //             this.physics.velocityFromAngle(angle, PROJECTILE_SPEED, bullet.body.velocity);
            //         }
            //     }
            // }, this);

            // //DEBUG
            // text.setText([
            //     'getTime: ' + game.getTime(),
            //     'nextFire: ' + nextFire
            // ]);
            
        }


       

        //#region CLIENTSOCKET
        function askNewPlayer()
        {
            client.socket.emit('newplayer');
        }

        function addNewPlayer(id,x,y, color, scene)
        {
            
            players[id] = scene.physics.add.sprite(x, y, 'cube');
            players[id].setCollideWorldBounds(true);
            players[id].body.allowRotation = false;
            players[id].setTintFill(color);

        }

        function playerMovementListener(cursors)
        {
            if(players[client.socket.id])
            {

                if(cursors.left.isDown)
                {
                    players[client.socket.id].setVelocityX(-PLAYER_SPEED);
                    client.socket.emit('keyPress', LEFT, {x:players[client.socket.id].x, y:players[client.socket.id].y});
                }
                else if(cursors.right.isDown)
                {
                    players[client.socket.id].setVelocityX(PLAYER_SPEED);
                    client.socket.emit('keyPress', RIGHT, {x:players[client.socket.id].x, y:players[client.socket.id].y});
                    // cube.setVelocityX(PLAYER_SPEED);
                }
                else 
                {
                    players[client.socket.id].setVelocityX(0);
                    client.socket.emit('stop', {x:players[client.socket.id].x, y:players[client.socket.id].y});
                    // cube.setVelocityX(0);
                } 
            
            
                if(cursors.up.isDown)
                {
                    players[client.socket.id].setVelocityY(-PLAYER_SPEED);
                    client.socket.emit('keyPress', UP, {x:players[client.socket.id].x, y:players[client.socket.id].y});
                    // cube.setVelocityY(-PLAYER_SPEED);
                }
                else if(cursors.down.isDown)
                {
                    players[client.socket.id].setVelocityY(PLAYER_SPEED);
                    client.socket.emit('keyPress', DOWN, {x:players[client.socket.id].x, y:players[client.socket.id].y});
                    // cube.setVelocityY(PLAYER_SPEED);
                }
                else
                {
                    players[client.socket.id].setVelocityY(0);
                    client.socket.emit('stop', {x:players[client.socket.id].x, y:players[client.socket.id].y});
                    // cube.setVelocityY(0);
                }
            }
           
        }
        //#endregion

        class BulletGroup extends Phaser.Physics.Arcade.Group {
            constructor(scene)
            {
                // Call the super constructor, passing in a world and a scene
                super(scene.physics.world, scene);

                // Initialize the group
                this.createMultiple({
                    classType:Bullet,
                    frameQuantity: 10, //create 10 instances
                    active: false,
                    visible:false,
                    key:'bullet'
                });
            }
        }

        class Bullet extends Phaser.Physics.Arcade.Sprite{
            constructor(scene, x, y) {
                super(scene, x, y, 'bullet');
            }

            shoot(x,y)
            {
                this.body.reset(x,y);
                this.setActive(true);
                this.setVisible(true);
            }
        }
    </script>
</body>
</html>
